#!/usr/bin/perl

use Moo;    # {{{1
use strictures 2;
use 5.006;
use 5.022_001;
use version; our $VERSION = qv('0.1');
use namespace::clean;    # }}}1

{

    # TODO: ensure exit code and output file existence
    #       properly reflect exist status
    # TODO: update perl package dependencies for plugin
    package Dn::ConsoleSelect;

    use Moo;    # {{{1
    use strictures 2;
    use namespace::clean -except => [ '_options_data', '_options_config' ];
    use autodie qw(open close);
    use Carp;
    use Const::Fast;
    use English qw(-no_match_vars);
    use Function::Parameters;
    use MooX::HandlesVia;
    use MooX::Options protect_argv => 0;
    use Term::Clui;
    local $ENV{CLUI_DIR} = 'OFF';    # do not remember responses
    use Term::Complete;
    use Types::Standard;
    use experimental qw(switch);

    const my $TRUE     => 1;
    const my $FALSE    => 0;
    const my $SHELL_OK => 0;         # }}}1

    # options

    # items          (-i)    {{{1
    option 'items' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        default  => sub { [] },
        short    => 'i',
        doc      => 'Items to select from (tab-separated list)',
    );

    method _get_items () {
        my $item_strings;
        my @item_strings = @{ $self->items };
        if (@item_strings) { $item_strings = $item_strings[0]; }
        my @items;
        if ($item_strings) {
            my @item_list = split /\t/xsm, $item_strings;
            push @items, @item_list;
        }
        return @items;
    }

    # select_method  (-m)    {{{1
    option 'select_method' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        default  => sub { [] },
        short    => 'm',
        doc      => 'Selection method (complete, filter, choose)',
    );

    method _select_method () {
        my $select_method;
        my @select_method = @{ $self->select_method };
        if (@select_method) { $select_method = $select_method[0]; }
        return $select_method;
    }

    # output_file    (-o)    {{{1
    option 'output_file' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        default  => sub { [] },
        short    => 'o',
        doc      => 'Path to output file capturing user selection',
    );

    method _output_file () {
        my $output_file;
        my @output_file = @{ $self->output_file };
        if (@output_file) { $output_file = $output_file[0]; }
        return $output_file;
    }

    # prompt         (-p)    {{{1
    option 'prompt' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        default  => sub { [] },
        short    => 'p',
        doc      => 'User prompt',
    );

    method _prompt () {
        my $prompt;
        my @prompt = @{ $self->prompt };
        if (@prompt) { $prompt = $prompt[0]; }
        return $prompt;
    }    # }}}1

    # attributes

    # _items    {{{1
    has '_items_list' => (
        is          => 'rw',
        isa         => Types::Standard::ArrayRef [Types::Standard::Str],
        lazy        => $TRUE,
        default     => sub { [] },
        handles_via => 'Array',
        handles     => {
            _items     => 'elements',
            _add_items => 'push',
            _has_items => 'count',
        },
        doc => 'Array of items to choose from',
    );

    # _selection    {{{1
    has '_selection' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::Str],
        default => sub {undef},
        doc     => 'Menu item selected by user',
    );    # }}}1

    # methods

    # main()    {{{1
    #
    # does:   main method
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method main () {

        # check args
        $self->_process_args;

        # make selection
        if ( $self->_make_selection ) {

            # write selection to output file
            $self->_output_selection;
        }

        # exit indicating success
        exit $SHELL_OK;
    }

    # _process_args()    {{{1
    #
    # does:   process arguments
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _process_args () {

        # check args

        my $vars_ok = $TRUE;

        if ( not $self->_prompt ) {
            $vars_ok = $FALSE;
            warn "$PROGRAM_NAME: no user prompt provided\n";
        }
        if ( not $self->_output_file ) {
            $vars_ok = $FALSE;
            warn "$PROGRAM_NAME: no output file path provided\n";
        }
        my @items_list = $self->_get_items;
        if ( not @items_list ) {
            $vars_ok = $FALSE;
            warn "$PROGRAM_NAME: no items provided to select from\n";
        }
        if ( not $self->_select_method ) {
            $vars_ok = $FALSE;
            warn "$PROGRAM_NAME: no selection method provided\n";
        }

        my %valid_method = map { $_ => $TRUE } qw(complete filter choose);
        my $method       = $self->_select_method;
        if ( not exists $valid_method{$method} ) {
            $vars_ok = $FALSE;
            die "$PROGRAM_NAME: invalid selection method '$method'\n";
        }

        if ( not $vars_ok ) { die "$PROGRAM_NAME aborting\n"; }

        # load items array

        $self->_add_items(@items_list);

        return;
    }

    # _select_complete()    {{{1
    #
    # does:   select using completion
    # params: nil
    # prints: feedback
    # return: boolean, whether item selected
    method _select_complete () {
        my @items  = $self->_items;
        my $prompt = $self->_prompt;
        say 'Completion shortcuts available while entering value'
            or croak 'Unable to write to console';
        say '[<Tab> completes, <C-d> prints completions, <C-u> erases input]'
            or croak 'Unable to write to console';
        my $item = Term::Complete::Complete( $prompt, @items );
        if ($item) { $self->_selection($item) }
        return $item;
    }

    # _select_filter()    {{{1
    #
    # does:   select using filter and choose
    # params: nil
    # prints: feedback
    # return: boolean, whether item selected
    method _select_filter () {
        my @items  = $self->_items;
        my $prompt = $self->_prompt;
        say 'Enter part of target value to narrow choices'
            or croak 'Unable to write to console';
        say 'Press <C-d> or <C-x> to clear string'
            or croak 'Unable to write to console';
        say 'Press Enter on empty field to choose from all items'
            or croak 'Unable to write to console';
        my $filter = Term::Clui::ask($prompt);
        my @matches;
        my $item;

        if ($filter) {
            @matches = grep {/$filter/xsmi} @items;
        }
        else {
            @matches = @items;
        }
        for ( scalar @matches ) {
            when ( $_ == 0 ) {
                die "$PROGRAM_NAME no matching item found\n";
            }
            when ( $_ == 1 ) {
                say "Only one matching item found: $matches[0]"
                    or croak 'Unable to write to console';
                $item = $matches[0];
            }
            default {
                say 'Navigate menu using arrow keys and hjkl keys'
                    or croak 'Unable to write to console';
                say 'Select item with Enter'
                    or croak 'Unable to write to console';
                say "Cancel selection with 'q' key"
                    or croak 'Unable to write to console';
                $item = Term::Clui::choose( $prompt, @matches );
            }
        }
        if ($item) { $self->_selection($item) }
        return $item;
    }

    # _select_choose()    {{{1
    #
    # does:   select using choose
    # params: nil
    # prints: feedback
    # return: boolean, whether item selected
    method _select_choose () {
        my @items  = $self->_items;
        my $prompt = $self->_prompt;
        say 'Navigate menu using arrow keys and hjkl keys'
            or croak 'Unable to write to console';
        say 'Select item with Enter'
            or croak 'Unable to write to console';
        say "Cancel selection with 'q' key"
            or croak 'Unable to write to console';
        my $item = Term::Clui::choose( $prompt, @items );
        if ($item) { $self->_selection($item) }
        return $item;
    }

    # _make_selection()    {{{1
    #
    # does:   dispatch to appropriate selection method
    # params: nil
    # prints: feedback
    # return: boolean, whether item selected
    method _make_selection () {
        my $method = $self->_select_method;
        for ($method) {
            when (/\Acomplete\Z/xsm) { return $self->_select_complete; }
            when (/\Afilter\Z/xsm)   { return $self->_select_filter; }
            when (/\Achoose\Z/xsm)   { return $self->_select_choose; }
        }
    }

    # _output_selection()    {{{1
    #
    # does:   write user selection to a disk file
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _output_selection () {
        my $selection   = $self->_selection;
        my $output_file = $self->_output_file;
        if ( not $selection ) { exit; }
        open my $fh, '>', $output_file
            or die "$PROGRAM_NAME unable to open '$output_file' for output\n";
        print {$fh} $selection
            or die "$PROGRAM_NAME unable to write to '$output_file'\n";
        close $fh;
    }    # }}}1

}

my $p = Dn::ConsoleSelect->new_with_options->main;

1;

# POD    {{{1
__END__

=encoding utf8

=head1 NAME

vim-dn-utils-console-select - select item from list in console

=head1 USAGE

B<vim-dn-utils-console-select> B<-p> I<prompt> B<-o> I<path> B<-l> I<items>
B<-m> I<'complete'|'filter'|'choose'>

B<vim-dn-utils-console-select -h>

=head1 REQUIRED ARGUMENTS

=over

=item B<-p>  B<--prompt>

Prompt preceding list of menu items.

Scalar string. Required.

=item B<-o>  B<--output_file>

Path to output file used for capturing user selection. A temporary file.

Scalar file path. Required.

=item B<-i>  B<--items>

Items to select from. Tab-separated list.

Scalar string. Required.

=item B<-m>  B<--select_method>

Method to use for selection. Must be one of: 'complete', 'filter', 'choose'.

Scalar string. Required.

=back

=head1 OPTIONS

=over

=item B<-h>  B<--help>

Display help and exit.

=back

=head1 DESCRIPTION

=head2 Overview

Enable user to select an item from a list on the console. This script is
designed to be used by vim scripts. It is included in the L<vim-dn-utils
plugin|https://github.com/dnebauer/vim-dn-utils> and used by the plugin
function C<dn#util#consoleSelect>.

=head2 Selection methods

There are three methods for selecting a list item. All can be used when list
items contain spaces.

=over

=item word completion

This method is used if C<complete> is supplied as the C<--select-method>
(C<-m>) option.

It relies on the user entering the first character(s) of the item and using
keyboard shortcuts to complete the item:

=over

=over

=item E<lt>TabE<gt>

Attempts completion, i.e., if the only possible matches remaining have
additional common characters remaining, they will be automatically entered. If
there is only one remaining match it will be completed.

=item E<lt>Ctrl-dE<gt>

Prints all possible completion matches.

=item E<lt>Ctrl-uE<gt>

Erase all input.

=back

=back

Uses the L<Term::Complete> module.

=item filter and choose

This method is used if C<filter> is supplied as the C<--select-method> (C<-m>)
option.

The user enter a fragment of the target item and selects from those items that
contain that fragment. This selection process operates as described below for
the selection method "choose".

Uses the L<Term::Clui> module.

=item choose

This method is used if C<choose> is supplied as the C<--select-method> (C<-m>)
option. The user selects from a list of all supplied items.

If the items won't fit on the screen, the user is asked to enter a substring as
a clue. As soon as the matching items will fit, they are displayed to be chosen
as normal. If the user pressed "q" at this choice, they are asked if they wish
to change their substring clue; if they reply "n" to this, choose quits and
returns undefined.

If the prompt is multi-line, the first line is put at the top as usual with the
choices arranged beneath it; the subsequent lines are formatted within the
screen width and displayed at the bottom. After the choice is made all but the
first line is erased, and the first line remains on-screen with the choice
appended after it. You should therefore try to arrange multi-line prompts so
that the first line is the question in short form, and subsequent lines are
explanation and elaboration.

Uses the L<Term::Clui> module.

=back

=head2 Capturing user selection in a temporary file

The user's selection is written to the temporary output file provided as a
parameter. No newline is appended to the result.

=head1 CONFIGURATION

The database feature of the Term::Clui module is switched off.

There is no user configuration of this script.

=head1 EXIT STATUS

The script exits with shell success or error codes as appropriate.

Since the script writes the user selection to the output file only when
successful, the presence or absence of content in the output file can be used
to detect success or failure. This script makes no attempt to delete the output
file, or remove its content, in the event of failure. So, to use output file
content as a marker of success or failure the calling application must ensure
the output file is absent or empty before calling this script.

=head1 DIAGNOSTICS

TBA.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 DEPENDENCIES

=head2 Perl modules

autodie, Const::Fast, English, experimental, Function::Parameters, Moo,
MooX::HandlesVia, MooX::Options, namespace::clean, strictures, Term::Clui,
Term::Complete, Types::Standard.

=head2 Executables

perl.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2021 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
# vim:foldmethod=marker:
