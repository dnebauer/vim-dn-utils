#!/usr/bin/perl 

# use statements                                                       {{{1
use strict;
use warnings;
use 5.006;
use 5.022.0;
use English qw(-no_match_vars);
use Term::Complete;
use Env qw(CLUI_DIR);
use Term::Clui;
$CLUI_DIR = 'OFF';    # do not remember responses
use experimental 'switch';

# variables                                                            {{{1
my $SELF     = 'dn-util-complete';
my $TRUE     = 1;
my $FALSE    = 0;
my $SHELL_OK = 0;
my ( $name_single, $name_plural, $output_file, @items, $select_method );

# process arguments                                                    {{{1
# - cycle through @ARGV                                                {{{2
# . tried using for..when(grep...) but got stupid smartmatch errors
#   saying --name-single was not numeric (!!) so fell back on this
#   ugly and inefficient 'grep and do' method
my @opts_help   = qw(-h --help);
my @opts_single = qw(-s --name-single);
my @opts_plural = qw(-p --name-plural);
my @opts_output = qw(-o --output-file);
my @opts_items  = qw(-i --items);
my @opts_method = qw(-m --select-method);
my @opts_all    = (
    @opts_help,   @opts_single, @opts_plural,
    @opts_output, @opts_items,  @opts_method
);

while ( my $opt = shift @ARGV ) {

    # --help
    if ( grep { $opt eq $_ } @opts_help ) {
        say "USAGE: $SELF [-npoim] [long options...]";
        say '';
        say 'Options requiring a string value:';
        say '    -n --name-single    Noun for single item';
        say '    -p --name-plural    Collective noun for items';
        say '    -o --output-file    Path of output file to hold result';
        say '    -i --items          Tab-separated list of items';
        say "    -m --select-method  Selection method ('complete'|'filter')";
        say '';
        say 'Options requiring no value:';
        say '    -h --help           Display this help message';
        exit $SHELL_OK;
    }

    # --name-single
    if (grep { $opt eq $_ } @opts_single ) {
        my $val = shift @ARGV;
        if ( defined $val and $val ne q{} ) { $name_single = $val; }
    }

    # --name-plural
    if (grep { $opt eq $_ } @opts_plural ) {
        my $val = shift @ARGV;
        if ( defined $val and $val ne q{} ) { $name_plural = $val; }
    }

    # --output-file
    if (grep { $opt eq $_ } @opts_output ) {
        my $val = shift @ARGV;
        if ( defined $val and $val ne q{} ) { $output_file = $val; }
    }

    # --select-method
    if (grep { $opt eq $_ } @opts_method  ) {
        my $val = shift @ARGV;
        if ( defined $val and $val ne q{} ) { $select_method = $val; }
    }

    # --items
    if (grep { $opt eq $_ } @opts_items ) {
        my $val = shift @ARGV;
        if ( defined $val and $val ne q{} ) {
            push @items, split( /\t/, $val );
        }
    }

    # default
    if (not(grep { $opt eq $_ } @opts_all )) {
        die "$SELF: invalid option '$opt'\n";
    }
}

# - check variables                                                    {{{2
my $vars_ok = $TRUE;
if ( not $name_single ) {
    $vars_ok = $FALSE;
    warn "$SELF: no item noun provided\n";
}
if ( not $name_plural ) {
    $vars_ok = $FALSE;
    warn "$SELF: no collective item noun provided\n";
}
if ( not $output_file ) {
    $vars_ok = $FALSE;
    warn "$SELF: no output file path provided\n";
}
if ( not @items ) {
    $vars_ok = $FALSE;
    warn "$SELF: no items provided to select from\n";
}
if ( not $select_method ) {
    $vars_ok = $FALSE;
    warn "$SELF: no selection method provided\n";
}
if ( not $vars_ok ) { die "$SELF: aborting\n"; }

# select item                                                          {{{1
my $item;
for ($select_method) {

    # use completion
    when ( $_ eq 'complete' ) {
        say "Completion shortcuts available while entering $name_single:";
        say '[<Tab> completes, <C-d> prints completions, <C-u> erases input]';
        $item = Term::Complete::Complete( "Enter $name_single: ", @items );
    }

    # use filter and select
    when ( $_ eq 'filter' ) {
        my $prompt = "Enter part of $name_single [<C-d> to quit]:";
        my $filter = Term::Clui::ask($prompt);
        my @matches;
        if ($filter) {
            @matches = grep {/$filter/xsmi} @items;
        }
        else {
            @matches = @items;
        }
        for ( scalar @matches ) {
            when ( $_ == 0 ) {
                die "$SELF: no matching $name_plural found\n";
            }
            when ( $_ == 1 ) {
                say "Only one matching $name_single found: $matches[0]";
                $item = $matches[0];
            }
            default {
                $item
                    = Term::Clui::choose( "Select $name_single:", @matches );
            }
        }
    }

    # invalid selection method
    default {
        die "$SELF: invalid selection method '$select_method' provided\n";
    }
}

if ( not $item ) { die "$SELF: no $name_single selected\n"; }

# output result                                                        {{{1
open my $fh, '>', $output_file
    or die "$SELF: unable to open '$output_file' for output";
print {$fh} $item
    or die "$SELF: unable to write to output file '$output_file'";
close $fh;

# exit indicating success                                              {{{1
exit $SHELL_OK;    #                                                   }}}1

# POD                                                                  {{{1
__END__

=head1 NAME

vim-dn-utils-console-select - select item from list in console

=head1 USAGE

B<vim-dn-utils-console-select> B<-s> I<noun> B<-p> I<noun> B<-o> I<path> B<-l> I<items> B<-m> I<'complete'|'filter'>

B<vim-dn-utils-console-select -h>

=head1 REQUIRED OPTIONS

=over

=item B<-s>  B<--single-name>

Noun used for a sinle list item. Example: 'element name'.

Scalar string. Required.

=item B<-p>  B<--name-plural>

Collective noun for list items. Example: 'element names'.

Scalar string. Required.

=item B<-o>  B<--output-file>

Path to output file used for capturing user selection. A temporary file.

Scalar file path. Required.

=item B<-i>  B<--items>

Items to select from. Tab-separated list.

Scalar string. Required.

=item B<-m>  B<--select-method>

Method to use for selection. Must be one of: 'complete', 'filter'.

Scalar string. Required.

=back

=head1 OPTIONS

=over

=item B<-h>  B<--help>

Display help and exit.

=back

=head1 DESCRIPTION

=head2 Overview

Enable user to select an item from a list on the console. This script is designed to be used by vim scripts. It is included in the L<vim-dn-utils plugin|https://github.com/dnebauer/vim-dn-utils> and used by the plugin function C<dn#util#consoleSelect>.

=head2 Selection methods

There are two methods for selecting a list item. Both can be used when list items contain spaces.

=over

=item word completion

This method is used if C<complete> is supplied as the C<--select-method> (C<-m>) option.

It relies on the user entering the first character(s) of the item and using keyboard shortcuts to complete the item:

=over

=over

=item E<lt>TabE<gt>

Attempts completion, i.e., if the only possible matches remaining have additional common characters remaining, they will be automatically entered. If there is only one remaining match it will be completed.

=item E<lt>Ctrl-dE<gt>

Prints all possible completion matches.

=item E<lt>Ctrl-uE<gt>

Erase all input.

=back

=back

Uses the L<Term::Complete> module.

=item filter and select

This method is used if C<filter> is supplied as the C<--select-method> (C<-m>) option.

The user enter a fragment of the target item and selects from those items that contain that fragment. E<lt>C-dE<gt> aborts the selection process.

Uses the L<Term::Clui> module.

=back

=head2 Capturing user selection in a temporary file

The user's selection is written to the temporary output file provided as a parameter. No newline is appended to the result.

=head2 Detecting script success and failure

The script exits with shell success or error codes as appropriate.

Since the script writes the user selection to the output file only when successful, the presence or absence of content in the output file can be used to detect success or failure. This script makes no attempt to delete the output file, or remove its content, in the event of failure. So, to use output file content as a marker of success or failure the calling application must ensure the output file is absent or empty before calling this script.

=head1 DEPENDENCIES

=head2 Perl modules

English, Env, experimental, Term::Clui, Term::Complete.

=head2 Executables

perl.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 COPYRIGHT

Copyright (c) 2016 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=cut
# vim:fdm=marker:
